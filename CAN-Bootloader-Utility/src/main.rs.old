extern crate libc;
use libc::*;
use std::io;
use std::io::prelude::*;
use std::fs::File;
use std::io::BufReader;
use std::borrow::ToOwned;

#[link(name = "canlib32")]
extern {
	fn canOpenChannel(ctrl: u16, flags: u16) -> i16;
	fn canInitializeLibrary();
	fn canSetBusParams(handle: i16, bitrate: i32, tseg1: u16, tseg2: u16, sjw: u16, noSamp: u16, syncmode: u16) -> i16;
	fn canWriteWait(handle: i16, id: u32, msg: *const c_void, dlc: u16, flag: u16, timeout: u32) -> i16;
	fn canWrite(handle: i16, id: u32, msg: *const c_void, dlc: u16, flag: u16) -> i16;
    fn canWriteSync(handle: i16, timeout: u32) -> i16;
	fn canBusOn(handle: i16) -> i16;
}

fn main() {
    // CAN library initialization
	
	unsafe {canInitializeLibrary()};
	
	let hndl = unsafe {canOpenChannel(0, 0)};
	
	if hndl < 0 {
		println!("Failed to open CAN channel!. Error: {}", hndl);
		return
	}
	
	let bitrate = -2; // 500 Kb/sec
	let mut result = unsafe {canSetBusParams(hndl, bitrate, 0, 0, 0, 0, 0)};
	
	if result != 0 {
		println!("Failed to set CAN bus parameters. Error: {}", result);
		return
	}
	
	result = unsafe {canBusOn(hndl)};
	if result != 0 {
		println!("Failed to go bus on. Error: {}", result);
		return
	}
	
	
	// Attempt to read program hex file
	let mut f =  match File::open("MCN.hex") {
		Ok(f) => f,
		Err(e) => {
			println!("{}", e);
			return
		}
	};
	
	let mut file_contents = BufReader::new(&f);
	
	let mut program_vec: Vec<String> = Vec::new();
	let mut is_first_line = true;
	
	// Obtain initialization portion of first line
	let mut first_line = String::new();
	
	file_contents.read_line(&mut first_line).unwrap();
	first_line = first_line.to_owned();
	let strOut = clean_line(&mut first_line);
	let mut len = strOut.len();
	
	let (initStream, mut progStream) = obtain_init_stream(&strOut);
	len -= 46;
	// Send the beginning of the bootload program over CAN
	can_send_init(hndl, &initStream);
	

	let section_length = get_section_length(&progStream);
	println!("Section length: {}", section_length);
	let mut index = 4;
	let mut bytes_sent = 0;
	while bytes_sent < (section_length*4) {
		let byte1 = (convert_ascii_to_hex(progStream.as_bytes()[index]) << 4) + convert_ascii_to_hex(progStream.as_bytes()[index+1]);
		let byte2 = (convert_ascii_to_hex(progStream.as_bytes()[index+2]) << 4) + convert_ascii_to_hex(progStream.as_bytes()[index+3]);
		println!("Byte1: {}, Byte2: {}", byte1, byte2);
		can_send_stream(hndl, byte1, byte2);
		bytes_sent += 4;
		index += 4;
		println!("Index: {}, Len: {}", index, len);
		if index >= (len-4) {
			first_line.clear();
			file_contents.read_line(&mut first_line).unwrap();
			progStream = clean_line(&mut first_line);
			len = progStream.len();
			println!("Stream: {}", progStream);
			index = 0;
		}
	}
	println!("Bytes sent: {}", bytes_sent);
	/*
	for line in file_contents.lines() {
	
		let mut line_string = line.unwrap();
		let (strOut, len) = clean_line(&mut line_string);
		
		if is_first_line == true {
		
			if len <= 44 {
				println!("Error decoding program hex file");
				return
			}
			let (initStream, progStream) = obtain_init_stream(&strOut);
			//program_vec.append(initStream.to_string());
			
		}
		
	}
	*/
	/*
	for byte in f.bytes() {
		let byteVal = byte.unwrap();
		if byteVal != 0x3a // If not the : ascii character
		{
			msgData[1] = byteVal;
			result = unsafe {canWriteWait(hndl, 0, msgData.as_mut_ptr() as *mut c_void, 2, 0, 10000)};
			if result != 0 {
				println!("Failed to send byte: {}", byteVal);
				return
			}
		}
	}
	*/
}

/// This function cleans the prefix data from each hex program line.
///
/// @pre	..
///	@param	line (&str) - The line to clean by removing the unneeded prefix data
///	@return	(&str, usize) The str slice which is the line with the prefix removed and the length of the
///			the new line.
fn clean_line(line: &str) -> (String)
{
	let mut result = &line[9..];
	
	return result.to_string()
}

///	This function takes the first line of a program hex file and splits it between
///		1. init stream + entrypoint 
///		2. The first program section stream
///	
///	@pre	str has a length that is greater than 44 bytes
///	@param	line (&str) - The line to obtain the init stream from.
///	@return	(&str, &str) where the first string is the init stream and the second str slice is
///			the rest of the contents from the line
fn obtain_init_stream(line: &str) -> (String, String)
{
	let (str1, str2) = line.split_at(44);
	return (str1.to_string(), str2.to_string())
}

/// This function takes the first two bytes from a program section (the ascii encoded length)
/// and converts the ascii characters to an u16 integer that represents the length.
///
///	@pre	
fn get_section_length(line: &str) -> u16
{
	// Read first ascii character (first byte), convert to hex value that the ASCII represents
	let mut ascii_char = line.as_bytes()[0];
	let mut length: u16 = (convert_ascii_to_hex(ascii_char) as u16) << 4;
	ascii_char = line.as_bytes()[1];
	length += convert_ascii_to_hex(ascii_char) as u16;
	
	ascii_char = line.as_bytes()[2];
	length += (convert_ascii_to_hex(ascii_char) as u16) << 12;
	length += (convert_ascii_to_hex(ascii_char) as u16) << 8;
	
	return length
}

fn convert_ascii_to_hex(ascii_char: u8) -> u8
{
	if ascii_char > 64 {
		return ascii_char - 55
	}
	else {
		return ascii_char - 48
	}
}

fn can_send_init(handle: i16, init_stream: &str) {
	let mut bytes_handled = 0;
	let mut msg_data: [u8; 2] = [0, 0];
	
	for byte in init_stream.bytes() {
		msg_data[(bytes_handled/2)] += convert_ascii_to_hex(byte) << (4 * ((bytes_handled+1)%2));
		if bytes_handled == 3 {
			let result = unsafe {canWriteWait(handle, 0, msg_data.as_mut_ptr() as *mut c_void, 2, 0, 10000)};
			
			while result != 0 {
				println!("Failed to send CAN init message: {}, {}", msg_data[0], msg_data[1]);
				
				// Attempt to resend message
				let result = unsafe {canWriteWait(handle, 0, msg_data.as_mut_ptr() as *mut c_void, 2, 0, 10000)};
			}
			bytes_handled = 0;
			msg_data = [0, 0];
		}
		else {
			bytes_handled += 1;
		}
	}
}

fn can_send_stream(handle: i16, byte1: u8, byte2: u8)
{
	let mut msg_data: [u8; 2] = [byte1, byte2];
	let result = unsafe {canWriteWait(handle, 0, msg_data.as_mut_ptr() as *mut c_void, 2, 0, 10000)};
	while result != 0 {
		println!("Failed to send CAN message: {}, {}", byte1, byte2);
		let result = unsafe {canWriteWait(handle, 0, msg_data.as_mut_ptr() as *mut c_void, 2, 0, 10000)};
	}
}